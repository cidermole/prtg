{
    "project_name":  "prtg",
    "project_long_name": "{{ cookiecutter.project_name }}",
    "project_description": "Python module to manage PRTG servers",
    "project_long_description": "{{ cookiecutter.project_description }}",
    "project_slug":  "{{ cookiecutter.project_name.lower()|replace(' ', '_')|replace('-', '_')|replace('.', '_')|trim() }}",
    "github_org": "timgates42",
    "github_repo": "prtg",
    "project_url": "https://github.com/{{ cookiecutter.github_org }}/{{ cookiecutter.github_repo }}",
    "py_modulename":  "{{ cookiecutter.project_slug }}",
    "community_name":  "prtg-dev",
    "dictionary": "en_AU",
    "docker_application_tagname": "app",
    "docker_workspace_dirname": "workspace",
    "docker_application_dirname": "{{ cookiecutter.docker_application_tagname }}",
    "author_email": "hutchris@gmail.com",
    "author_name": "Chris Hutchings",
    "maintainer_name": "Tim Gates",
    "maintainer_email": "tim.gates@iress.com",
    "project_email": "{{ cookiecutter.maintainer_email }}",
    "azure_buildid": "14",
    "azure_user": "timgates",
    "azure_project": "{{ cookiecutter.azure_user }}",
    "build_status_url": "https://dev.azure.com/{{ cookiecutter.azure_user }}/{{ cookiecutter.azure_project }}/_apis/build/status/{{ cookiecutter.github_org }}.{{ cookiecutter.github_repo }}?branchName=master",
    "build_url": "https://dev.azure.com/{{ cookiecutter.azure_user }}/{{ cookiecutter.azure_project }}/_build/latest?definitionId={{ cookiecutter.azure_buildid }}&branchName=master",
    "pypi_name": "{{ cookiecutter.project_name }}",
    "readthedocs_name": "{{ cookiecutter.project_name }}",
    "app_requirements": "bs4\nclick\nfuture\nlxml\nrequests",
    "cov_fail_under": "0",
    "travis_status_url": "https://travis-ci.org/{{ cookiecutter.github_org }}/{{ cookiecutter.github_repo }}.svg?branch=master",
    "travis_build_url": "https://travis-ci.org/{{ cookiecutter.github_org }}/{{ cookiecutter.github_repo }}",
    "appveyor_status_url": "https://ci.appveyor.com/api/projects/status/github/{{ cookiecutter.github_org }}/{{ cookiecutter.github_repo }}/branch/master?svg=true",
    "appveyor_build_url": "https://ci.appveyor.com/project/{{ cookiecutter.github_org }}/{{ cookiecutter.github_repo }}",
    "installation_notes": "Note: if using Python 3.4 the latest version of lxml only supports python 3.5 and above so install lxml 4.3.4",
    "extended_readme": "# Warnings\n\nTested only on Python 3.5.2 so far. Does work with python 2.7 but not\nextensively tested. \n\n# Description\n\nThis is a Python module to facilitate in managing PRTG servers from CLI or for\nautomating changes. It is really useful for scripting changes to prtg objects.\n\nThe prtg\\_api no longer uses a config file. Instead you need to enter your\nPRTG parameters when initiating the prtg\\_api class. This change was to allow\nthis to be used in a more flexible way, or to manage multiple PRTG instances,\nyou can still set up a local config file for your parameters if you wish. The\nparameters for initiating the prtg\\_api class are:\n\n```\nprtg.PRTGApi(host,user,passhash,protocol=\'https\',port=\'443\',rootid=0)\n```\n\nUpon initialisation the entire device tree is downloaded and each probe,\ngroup, device, sensor and channel is provided as a modifiable object. From the\nmain object (called prtg in example) you can access all objects in the tree\nusing the prtg.allprobes, prtg.allgroups, prtg.alldevices and prtg.allsensors\nattributes. The channels are not available by default, you must run\nsensor.get\\_channels() to the get the child channels of that sensor.\n\nYou can also set the root of your sensor tree as a group that is not the root\nof PRTG. This was added to allow a partial sensortree to be downloaded where\nyour PRTG server may have many objects or to provide access to a user with\nrestricted permissions.\n\nWhen you are accessing an object further down the tree you only have access to\nthe direct children of that object. This for example will show the devices\nthat are in the 4th group of the allgroups array:\n\n```\nfrom prtg import PRTGApi\n\nprtg = PRTGApi(\'192.168.1.1\',\'prtgadmin\',\'0000000000\')\n\nprtg.allgroups[3].devices\n```\n\nProbe and group objects can have groups and devices as children, device\nobjects have sensors as children and sensors can have channels as children. \n\n```\nfrom prtg import PRTGApi\n\nprtg = PRTGApi(\'192.168.1.1\',\'prtgadmin\',\'0000000000\')\n\nprobeobject = prtg.allprobes[0]\ngroups = probeobject.groups\ndevices = probeobject.devices\n\ndeviceobject = devices[0]\nsensors = deviceobject.sensors\n\nsensorobject = sensors[0]\nsensorobject.get_channels()\n\nchannel = sensorobject.channels[0]\n```\n\n\nCurrent methods and parameters (\\* = required) on all objects include:\n- rename()\n- pause(duration=0,message=\'\') (pause and resume on a channel will change the parent sensor)  \n- resume()\n- clone(newname=\'\'\\*,newplaceid=\'\'\\*)\n- delete(confirm=True) (you can\'t delete the root object or channels)\n- refresh()\n- set\\_property(name\\*,value\\*)\n- get\\_property(name\\*)\n- set\\_additional\\_param(param\\*) (for custom script sensors)\n- set\\_interval(interval\\*)\n- set\\_host(host\\*) (ip address or hostname)\n- search\\_byid(id)\n- add\\_tags([\'tag1\',\'tag2\']\\*,clear\\_old=False)\n\nTo come:\n- move\n\nIf you are making small changes such as pause, resume, rename; the local data\nwill update as you go. If you are doing larger changes you should refresh the\ndata after each change. If you refresh the main prtg object it will refresh\neverything otherwise you can just refresh an object further down the tree to\nonly refresh part of the local data. To refresh an object call the .refresh()\nmethod.\n\nThe set\\_property method is very powerful and flexible. You can change anything\nfor an object that you can change in the objects settings tab in the web ui. I\nwill add the more commonly used settings as separate methods. You can use the\nget\\_property method to test the name of the property:\n\n```\nfrom prtg import PRTGApi\n\nprtg = PRTGApi(\'192.168.1.1\',\'prtgadmin\',\'0000000000\')\nprtg.get_property(name=\'location\')\n#returns the location and sets prtg.location to the result.\n\nprtg.set_property(name=\'location\',value=\'Canada\')\n```\n\nThere are delays with some actions such as resuming so you should add time\ndelays where appropriate.\n\nexample usage:\n\n```\nimport time\nfrom prtg import PRTGApi\n\nprtg = PRTGApi(\'192.168.1.1\',\'prtgadmin\',\'0000000000\')\n\nfor device in prtg.alldevices:\n  if device.id == "1234":\n    deviceobj = device\n\ndeviceobj.pause()\ndeviceobj.clone(newname="cloned device",newplaceid="2468")\n\ntime.sleep(10)\n\nprtg.refresh()\n\nfor device in prtg.alldevices:\n  if device.name = "cloned device":\n    device.resume()\n\n```\n\nThe PRTGApi class can be used with the root id set as the root group, a probe,\nor a group. If you wanted to manage a device or sensor and don\'t want to\ndownload the entire sensortree to loop through the results; you can use the\nPRTGDevice and PRTGSensor classes. For example:\n\n```\nhost = \'192.168.1.1\'\nport = \'80\'\nuser = \'prtgadmin\'\npasshash = \'0000000\'\nprotocol = \'http\'\ndeviceid = \'2025\'\n\ndevice = PRTGDevice(host,port,user,passhash,protocol,deviceid)\n\nsensorid = \'2123\'\n\nsensor = PRTGSensor(host,port,user,passhash,protocol,sensorid)\n```\n",
    "supports_pytwo": [
        "yes",
        "no"
    ],
    "license": [
        "MIT",
        "GPLv3+"
    ]
}
